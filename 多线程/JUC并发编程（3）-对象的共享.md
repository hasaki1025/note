# JUC并发编程（3）-对象的共享

- ## 可见性

  - 指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

  - 重排序
    - 重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段
    
  - 最低安全性
    - 当线程在没有同步的情况下读取变量，可能会得到一个失效值但至少是之前线程设置的值，这也是最低安全性
    - 最低安全性适用于绝大部分变量，但是对于非volatile类型的64数值变量，JVM运行将读操作或写操作分解为两个32位操作。
    
  - 加锁与可见性
    - 锁内部的执行都是可预测的
    
  - Volatile变量
    - 一种稍弱的同步机制，当把变量声明位volatile类型后，编译器和运行时都会注意到这个变量是共享的，因此不会将该变量上的操作和其他内存操作一起重排序。
    
    - Volatile变量每次读取获得的都是最新写入的值（保证可见性）
    
    - 特性（原理：通过内存屏障实现）
      - 当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；
      
      - 禁止指令重排序
      
      - 如果是写操作，它会导致其他CPU中对应的缓存行无效。
      
      - 原理详解
      
        ```java
        底层在给volatile变量赋值时，会发送一个lock指令，这个指令会锁住特定的内存地址，并将线程中该变量缓存行的数据立即写回主存，并触发总线嗅探机制。读取和修改都会经过总线，总线嗅探机制会嗅探总线上共享变量的改变，如果CPU发现自己线程中缓存的该共享变量被修改了，会将该缓存行置为无效状态，然后从主存中再次加载该共享变量的值。
            
        lock指令是一个汇编指令，在执行它时，会使CPU释放一个LOCK# 信号，它会锁住对应变量的内存地址，这样就确保在多处理器或多线程的情况下互斥使用这个内存地址，相当于当前线程给这个变量赋值时，其他线程都不能读取。当指令执行完毕，这个锁定动作也就会消失。
        ————————————————
        版权声明：本文为CSDN博主「吖土豆」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
        原文链接：https://blog.csdn.net/qq_42878176/article/details/128286908
        ```
      
        
      
    - 常用场景
      - 检查某个状态标记以判断是否推出循环
      
    - 不可用的场景
      - 递增操作（除非能确保只有一个线程对变量执行写操作）
      
    - 使用条件
      - 写入操作不依赖变量当前值或者能保证只有一个线程更新变量值
      - 访问变量时不需要加锁
      - 不会和其他状态变量一起纳入不变性条件

- ## 发布和逸出

  - 发布

    - 使对象能够在当前作用域之外的代码使用（引用传递，static变量等）
    - 发布内部状态可能会破坏封装性，如果在对象构造完成之前发布对象可能会破坏线程安全性
    - 发布的同时需要保证线程安全性（在多线程情况下）
    - 发布一个变量可能会间接发布另一个对象（List对象）

  - 逸出

    - 某个不该被发布的对象被发布称为逸出（如private通过get方法发布）

    - 隐式导致this指针逸出

      ```java
      public class ThisEscape{
          public ThisEscape(EventSource source)
          {
              source.registerListener{
                  new EventListener()
                  {
                      public void onEvent(Event e)
                      {
                          //在这里能调用ThisEscape.this并对其做出一些意想不到的修改，最重要的是此时ThisEscape并未完全初始化
                          doSomething(e);
                      }
                  }
                  
              }
          }
      }
      ```

      - 类似的还有在初始化方法中创建一个线程并启动（正确的做法是创建但是不启动，而是通过其他方法启动）

- ## 线程封闭

  - 当访问共享可变数据时如何避免同步

    - 不共享数据，将数据封装类中，只在单线程下访问
      - 类似实例如JDBC的Connection池
    - 栈封闭
      - 只有局部变量访问对象

    - ThreadLocal类

      - 每个线程都拥有该变量的副本，类似于Map<Thread,Object>

        ```java
        private static ThreadLocal<Connection> connectionHolder=new ThreadLocal<Connection>(){
            public Connection initialValue()
            {
                return DriverManager.getConnection(DB_URL);
            }
        }
        publice static Connection getConnection()
        {
            return connectionHolder.get();
        }
        ```

- ## 不变性

  - 不变对象一定是线程安全的
  - 不变对象的定义
    - 创建对象后其状态不能修改
    - 所有域都是final（也不一定，如String类型）
    - 正确创建的（this指针没有逸出）
  - 误区
    - 全用final修饰的类并不一定是不变的
    - 不变对象的域不一定都是final域
  - 除非需要更高的可见性，否则应该将所有的域都设置为private，除非需要更高的可变性否则应该将所有的域都设置为final
  
- ## 安全发布

  - 不可变对象和初始化安全性

    - 在发布不可以变对象时可以不采取同步

  - 可变对象的安全发布

    - 常用模式

      - 在静态初始化函数中初始化一个对象

        ```java
        public static Holder holder=new Holder();
        ```

        

      - 将对象引用保存在volatile类或者AtomicReferance对象中

      - 将对象引用保存在正确构造对象的final域中

      - 将对象引用保存在一个由锁保护的域中

      - 将对象引用保存在线程安全容器中（Future,Exchanger等也可以做到）

  - 事实不可变对象

    - 通俗的说既是没有写线程修改其值（虽然该对象是可变的）
    - 对于事实不可变对象只需要安全发布即可访问

  - 三种对象

    - 不可变对象
      - 无需同步，可采用任意机制发布
    - 事实不可变对象
      - 需要通过安全发布但是访问无需多余同步措施
    - 可变对象
      - 需要安全发布且需要采用同步措施