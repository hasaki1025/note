- mov al,[0] 指令括号中的0是内存的偏移地址，程序的基地址存储在DS寄存器中

- 86CPU不支持直接将数据送入段寄存器（如DS）中

- 汇编调试

  - t：继续执行

  - r:查看所有寄存器内容

  - 调试指令解析https://blog.csdn.net/weixin_43916755/article/details/120297723

  - SS寄存器：段寄存器，一般用于指向栈起始位置（栈底，但其实在内存中栈是向下生长的，所以应该是“栈顶”）

  - SP寄存器：SP指向栈的最后一个元素（或者最后一个元素的下一个地址）

  - 循环指令

    ```asm
    code segment
    	mov ax,2
    	mov cx,3
    	s : add ax,ax
    	loop s
    	mov bx,ax
    
    code ends
    
    end
    ```

    - s作为一个标记，代表add ax,ax 指令的地址
    - 执行到loop时会检查cx中的值是否为0如果不是则继续执行

  - bx一般用于存放偏移地址

  - 使用start标记代码的起始位置

    ```asm
    start 
    end start
    ```

    - 原先的end由end start取代，start标记第一条指令的位置

  - 段标记的作用

    ```asm
    stack segment
     dw 0
    stack ends
    ```

    - stack segment标记了段的起始地址，可以在指令中使用，如mov ax ,stack就是将stack的起始地址送入ax中

  - 只有四个寄存器可以用来寻址

    - bx（基址寄存器）、si（变址寄存器）、di（变址寄存器）、bp(堆栈基地址)
    - ![image-20230706163809051](C:\Users\pcdn\AppData\Roaming\Typora\typora-user-images\image-20230706163809051.png)

  - offset

    ```asm
    mov ax,offset start 
    ```

    - offset用于取得标号的偏移地址

  - jmp 

    - jmp short （段内短转移）只对IP修改（无需生成目的地址只需要在IP地址的基础上增加相对的偏移地址）
    - jmp far ptr （段间转移）

